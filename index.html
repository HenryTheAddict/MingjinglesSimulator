<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mingle my jingles!</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .food-img {
            width: 200px;
            height: 200px;
            cursor: pointer;
            transition: transform 0.1s;
            user-select: none;
            -webkit-user-drag: none;
        }

        .food-img:active {
            transform: scale(0.95);
        }

        .bounce {
            animation: bounce 0.5s;
        }

        .mini-burger { /* This class is no longer used for 3D floating burgers */
            position: absolute;
            width: 30px;
            height: 30px;
            pointer-events: none;
            animation: floatUp 1s forwards;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }

        @keyframes bounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .food-container {
            min-height: 220px;
            position: relative;
        }

        .stats-container, .upgrades-container {
            background-color: rgba(0, 0, 0, 0.25); /* Darker semi-transparent background */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); /* For Safari */
            padding: 20px;
            border-radius: 15px; /* Softer radius */
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* Adjusted shadow */
            border: 1px solid rgba(255, 255, 255, 0.15); /* Subtle edge */
            color: #f0f0f0; /* Ensure text is light and legible */
            transition: transform 0.1s ease-out; /* For parallax effect */
        }

        #achievement-alert {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1050; /* Ensure it's above most other elements, Bootstrap modals are 1050+ */
            width: 380px; /* Increased width */
            padding: 20px 25px; /* Increased padding */
            background: linear-gradient(145deg, #f8e076, #dfbe53); /* Gold gradient */
            color: #4A3B00; /* Darker gold/brown text for contrast */
            border: 2px solid #c8a840; /* Gold border */
            border-radius: 12px; /* Softer corners */
            box-shadow: 0 8px 25px rgba(0,0,0,0.35); /* More pronounced shadow */
            font-size: 1.15em; /* Slightly larger font */
            font-weight: bold;
            display: flex; /* For aligning icon and text */
            align-items: center; /* Align icon and text vertically */
            animation: slideInEnhanced 0.6s cubic-bezier(0.25, 0.8, 0.25, 1) forwards,
                       pulseAchievement 1.8s infinite 0.7s; /* New entry and pulse animation */
            transform: translateX(110%); /* Initial off-screen state for animation */
            opacity: 0; /* Initial hidden state for animation */
        }

        #achievement-alert.d-none { /* Ensure it's properly hidden when d-none is active */
            display: none !important; /* Override flex if d-none is added */
        }

        #achievement-alert::before {
            content: 'üèÜ'; /* Trophy icon */
            font-size: 1.8em; /* Larger icon */
            margin-right: 15px; /* Space between icon and text */
            line-height: 1; /* Ensure icon aligns well */
        }

        .auto-clicker-visual {
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            animation: rotate 3s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg) translateX(100px) rotate(0deg); }
            to { transform: rotate(360deg) translateX(100px) rotate(-360deg); }
        }

        /* Progress Bar Container Styling */
        .progress {
            height: 30px; /* Increased height */
            border-radius: 15px; /* Rounded ends */
            background-color: rgba(0, 0, 0, 0.3); /* Dark, slightly transparent background */
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.4); /* Inner shadow for depressed look */
            padding: 3px; /* Add a little padding so the bar inside doesn't touch edges */
        }

        /* Progress Bar Fill Styling */
        .progress-bar {
            border-radius: 12px; /* Rounded to fit neatly inside the container's padding */
            background-image: linear-gradient(45deg, #28a745, #218838); /* More vibrant gradient for success (default green) */
            box-shadow: 0 0 5px rgba(40, 167, 69, 0.7), 0 0 10px rgba(40, 167, 69, 0.5); /* Glow effect for the bar */
            /* The .progress-bar-striped and .progress-bar-animated classes from Bootstrap will still apply */
        }

        /* Ensuring other Bootstrap progress bar variants would also look good if used */
        .progress-bar.bg-info { /* Example for .bg-info if it were used for rank */
             background-image: linear-gradient(45deg, #17a2b8, #138496);
             box-shadow: 0 0 5px rgba(23, 162, 184, 0.7), 0 0 10px rgba(23, 162, 184, 0.5);
        }
        .progress-bar.bg-warning {
             background-image: linear-gradient(45deg, #ffc107, #e0a800);
             box-shadow: 0 0 5px rgba(255, 193, 7, 0.7), 0 0 10px rgba(255, 193, 7, 0.5);
        }
         .progress-bar.bg-primary { /* Rank progress uses default (blueish) in this game */
             background-image: linear-gradient(45deg, #007bff, #0069d9);
             box-shadow: 0 0 5px rgba(0, 123, 255, 0.7), 0 0 10px rgba(0, 123, 255, 0.5);
        }


        /* General Button Styling */
        .btn {
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out, transform 0.15s ease-in-out;
            font-weight: 500; /* Slightly bolder text */
        }

        .btn:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transform: translateY(-1px); /* Slight lift */
        }

        .btn:active {
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transform: translateY(1px); /* Press down effect */
        }

        /* Specific Button Colors (adjusting shades slightly if needed, keeping originals for now) */
        /* .btn-success (used by #multiplier-upgrade) - Bootstrap default is fine or can be overridden */
        /* .btn-info (used by #auto-clicker) - Bootstrap default is fine or can be overridden */
        /* .btn-warning (used by #auto-speed) - Bootstrap default is fine or can be overridden */


        .upgrade-card {
            background-color: rgba(0, 0, 0, 0.2); /* Consistent with new container backgrounds */
            border-radius: 12px; /* Softer and consistent */
            padding: 20px; /* More padding */
            margin-bottom: 15px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.15); /* Refined shadow */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }

        .upgrade-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.25); /* Enhanced shadow on hover */
        }

        .upgrade-card h5 { /* Ensure heading text is bright */
            color: #e9ecef;
        }
        .upgrade-card small { /* Ensure small text is bright */
            color: #adb5bd;
        }


        @keyframes slideIn { /* Original slideIn, modified slightly by enhancement to alert */
            from { transform: translateX(100%); }
            to { transform: translateX(0) scale(1); opacity: 1; }
        }

        @keyframes slideInEnhanced {
            0% { transform: translateX(110%) scale(0.8); opacity: 0; }
            30% { transform: translateX(110%) scale(0.8); opacity: 0; } /* Optional delay before moving */
            80% { transform: translateX(-5%) scale(1.05); opacity: 1; } /* Overshoot and bounce */
            100% { transform: translateX(0) scale(1); opacity: 1; }
        }

        @keyframes pulseAchievement {
            0% { box-shadow: 0 8px 25px rgba(0,0,0,0.35), 0 0 0 0 rgba(223, 190, 83, 0.7); }
            50% { box-shadow: 0 8px 30px rgba(0,0,0,0.45), 0 0 10px 15px rgba(223, 190, 83, 0); }
            100% { box-shadow: 0 8px 25px rgba(0,0,0,0.35), 0 0 0 0 rgba(223, 190, 83, 0); }
        }

        .sparkle {
            animation: sparkle 1s infinite;
        }

        @keyframes sparkle {
            0% { filter: brightness(100%); }
            50% { filter: brightness(150%); }
            100% { filter: brightness(100%); }
        }

        .level-up {
            animation: levelUp 1s;
        }

        @keyframes levelUp {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); color: #ffd700; }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-dark text-light">
    <div id="threejs-container" style="position: absolute; z-index: -1; top: 0; left: 0; width: 100%; height: 100%;"></div>
    <div class="container mt-5 text-center">
        <h1 class="mb-4 text-warning">üçî Bingle Jingle Simulingle's üçî</h1>
        
        <div class="stats-container mb-4">
            <h3>Rank: <span id="rank-name" class="text-info">Newbie Foodie</span></h3>
            <h4>Total Pounds: <span id="score" class="text-success">0</span></h4>
            <div class="progress mb-2">
                <div id="rank-progress" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
            </div>
            <h4>Pounds per Second: <span id="mps" class="text-primary">0</span></h4>
            <h5>Pounds per Click: <span id="multiplier" class="text-warning">1</span></h5>
        </div>

        <div class="food-container mb-4" id="food-container">
            <!-- <img src="https://em-content.zobj.net/thumbs/120/apple/325/hamburger_1f354.png"
                 id="food-btn" 
                 class="food-img"
                 alt="Click me!"> -->
        </div>

        <div class="upgrades-container">
            <h3 class="mb-3 text-warning">Upgrades</h3>
            <div class="row justify-content-center g-3">
                <div class="col-md-4">
                    <div class="upgrade-card">
                        <h5 class="text-info">Click Power</h5>
                        <button id="multiplier-upgrade" class="btn btn-success mb-2 w-100">
                            Upgrade Power (Cost: 10)
                        </button>
                        <small class="text-muted">Current: <span id="click-power">1</span> per click</small>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="upgrade-card">
                        <h5 class="text-info">Auto Clicker</h5>
                        <button id="auto-clicker" class="btn btn-info mb-2 w-100">
                            Buy Auto Clicker (Cost: 50)
                        </button>
                        <small class="text-muted">Owned: <span id="auto-count">0</span></small>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="upgrade-card">
                        <h5 class="text-info">Auto Speed</h5>
                        <button id="auto-speed" class="btn btn-warning mb-2 w-100">
                            Upgrade Speed (Cost: 100)
                        </button>
                        <small class="text-muted">Speed: <span id="auto-speed-level">1</span>x</small>
                    </div>
                </div>
            </div>
        </div>

        <div id="food-selection-container" class="mt-4">
            <h5 class="text-warning">Change Food</h5>
            <button class="btn btn-secondary food-select-btn me-2" data-foodid="hamburger">Burger</button>
            <button class="btn btn-secondary food-select-btn me-2" data-foodid="pizza">Pizza</button>
            <button class="btn btn-secondary food-select-btn" data-foodid="donut">Donut</button>
            <!-- Add more buttons as new items are created -->
        </div>

        <div class="achievements mt-4">
            <div id="achievement-alert" class="alert alert-success d-none" role="alert">
                Achievement Unlocked! üéâ
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- GLOBAL VARIABLES & CONSTANTS ---

        // Game State Variables
        let score = 0;
        let multiplier = 1; // Pounds per click
        let multiplierCost = 10;
        let autoClickerCount = 0;
        let autoClickerCost = 50;
        let autoSpeedLevel = 1;
        let autoSpeedCost = 100;
        let lastSave = Date.now(); // For auto-save timing
        let currentFoodItemId = 'hamburger'; // Default food item
        let unlockedFoodIds = []; // For tracking selected foods for achievements

        // Game Configuration Data
        const ranks = [
            { name: "Newbie Foodie", requirement: 0 },
            { name: "Snack Enthusiast", requirement: 50 },
            { name: "Food Explorer", requirement: 200 },
            { name: "Cuisine Master", requirement: 500 },
            { name: "Epic Gourmand", requirement: 1000 },
            { name: "Legendary Food King", requirement: 2500 },
            { name: "Minjigles God", requirement: 5000 }
        ];

        const achievements = [
            // Existing Corrected & Categorized
            { name: "First Bite", requirement: 1, unlocked: false, category: "milestone" },
            { name: "Hungry for More", requirement: 100, unlocked: false, category: "milestone" },
            { name: "Food Obeesed", requirement: 1000, unlocked: false, category: "milestone" }, // Score based
            { name: "mingled, and jingled ü¶ë", requirement: 1000, unlocked: false, category: "milestone" }, // Also score based, kept original req
            { name: "YOU BEAT MINGINGLES IN THE RANKING!!! üéâü™Ö", requirement: 2000000, unlocked: false, category: "milestone" },

            { name: "LAZY ü¶•, YOU ARE VERY USELESS AND LAZY!!!!!!", requirement: 1, unlocked: false, type: "autoClicker", category: "special" }, // Auto clicker related
            { name: "Automation Master", requirement: 5, unlocked: false, type: "autoClicker", category: "upgrade" },
            { name: "Speed Demon", requirement: 5, unlocked: false, type: "autoSpeed", category: "upgrade" },
            { name: "Speed v8", requirement: 8, unlocked: false, type: "autoSpeed", category: "upgrade" },
            { name: "speed v12", requirement: 12, unlocked: false, type: "autoSpeed", category: "upgrade" },
            { name: "speed v16", requirement: 16, unlocked: false, type: "autoSpeed", category: "upgrade" },

            // New Milestone Achievements (Score-based)
            { name: "Snack Packer", requirement: 5000, unlocked: false, category: "milestone" },
            { name: "Burger Flipper", requirement: 25000, unlocked: false, category: "milestone" },
            { name: "Feast Starter", requirement: 100000, unlocked: false, category: "milestone" },
            { name: "Millionaire Muncher", requirement: 1000000, unlocked: false, category: "milestone" },
            { name: "Burger Billionaire", requirement: 1000000000, unlocked: false, category: "milestone" },

            // New Upgrade Level Achievements
            // Click Power
            { name: "Heavy Hand", requirement: 25, unlocked: false, type: "clickPower", category: "upgrade" },
            { name: "Power Clicker", requirement: 50, unlocked: false, type: "clickPower", category: "upgrade" },
            { name: "Mighty Click", requirement: 100, unlocked: false, type: "clickPower", category: "upgrade" },
            // Auto Clicker Count
            { name: "Burger Brigade", requirement: 10, unlocked: false, type: "autoClicker", category: "upgrade" },
            { name: "Auto Army", requirement: 25, unlocked: false, type: "autoClicker", category: "upgrade" },
            { name: "Autonomous Collective", requirement: 50, unlocked: false, type: "autoClicker", category: "upgrade" },
            // Auto Speed Level
            { name: "Ludicrous Speed", requirement: 20, unlocked: false, type: "autoSpeed", category: "upgrade" },
            { name: "Warp Speed Engaged", requirement: 30, unlocked: false, type: "autoSpeed", category: "upgrade" },

            // New "Hidden" or Special Achievements (tracking logic to be added later)
            { name: "Just One More...", requirement: 666, unlocked: false, category: "special", type: "scorePrecision" },
            { name: "Click Frenzy", requirement: 10, unlocked: false, category: "special", type: "clicksInSec" },
            { name: "Early Bird", requirement: null, unlocked: false, category: "special", type: "timeOfDay" },

            // Achievements for new food items
            { name: "Pizza Time!", requirementType: "foodSelected", foodId: "pizza", unlocked: false, category: "discovery" },
            { name: "Donut Delight!", requirementType: "foodSelected", foodId: "donut", unlocked: false, category: "discovery" },
            { name: "Food Connoisseur", requirementType: "allFoodsSelected", unlocked: false, category: "collection" }
        ];

        // Three.js Variables
        let scene, camera, renderer, currentFoodModel, raycaster, mouse; // Renamed hamburgerModel
        const floatingBurgers3D = []; // Array to store active 3D floating burgers
        let isHovering = false; // For main food item hover state
        // Note: originalScale and hoverScale are now part of FoodItem defined in foodItems['hamburger']

        // Achievement Tracking Variables
        let clickTimestamps = []; // For "clicksInSec" achievement

        // --- FOOD ITEM DEFINITIONS ---
        class FoodItem {
            constructor(id, name, modelGenerator, originalScale, hoverScale, clickScale) {
                this.id = id;
                this.name = name;
                this.modelGenerator = modelGenerator;
                this.originalScale = originalScale;
                this.hoverScale = hoverScale;
                this.clickScale = clickScale;
                // Optional: this.baseClickValue = 1;
                // Optional: this.unlockRequirement = 0;
            }
        }

        const foodItems = {}; // Using an object for easy lookup by ID
        // --- UI ELEMENT REFERENCES ---
        const elements = {
            score: document.getElementById('score'),
            multiplier: document.getElementById('multiplier'),
            // foodBtn: document.getElementById('food-btn'), // 2D button, now unused
            foodContainer: document.getElementById('food-container'),
            multiplierUpgradeBtn: document.getElementById('multiplier-upgrade'),
            autoClickerBtn: document.getElementById('auto-clicker'),
            autoSpeedBtn: document.getElementById('auto-speed'),
            rankName: document.getElementById('rank-name'),
            achievementAlert: document.getElementById('achievement-alert'),
            mps: document.getElementById('mps'), // Pounds Per Second display
            rankProgress: document.getElementById('rank-progress'),
            clickPower: document.getElementById('click-power'), // Display for current click power
            autoCount: document.getElementById('auto-count'),   // Display for auto clicker count
            autoSpeedLevel: document.getElementById('auto-speed-level') // Display for auto speed level
        };

        // --- THREE.JS SETUP & ANIMATION ---

        /**
         * Initializes the Three.js scene, camera, renderer, lights, and initial objects.
         */
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha for transparent background if needed
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('threejs-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Fog for depth perception
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            // Create main interactive food model based on currentFoodItemId
            const currentFoodItem = foodItems[currentFoodItemId];
            if (!currentFoodItem) {
                console.error("Current food item not found:", currentFoodItemId);
                return;
            }
            currentFoodModel = currentFoodItem.modelGenerator();
            currentFoodModel.scale.copy(currentFoodItem.originalScale);
            scene.add(currentFoodModel);

            // Create decorative background elements
            createBackgroundElements();

            // Position the main food model within the designated container area
            positionCurrentFoodModel();

            camera.position.z = 5; // Camera distance from origin

            // Raycasting setup for mouse interactions
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event listeners for Three.js interactions
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('click', onThreeJSClick, false); // Renamed from onClick to avoid confusion
            window.addEventListener('resize', onWindowResize, false);
        }

        /**
         * Generates the 3D model for a hamburger.
         * @returns {THREE.Group} The hamburger model.
         */
        function generateHamburgerModel() {
            const group = new THREE.Group();
            const bunMaterial = new THREE.MeshStandardMaterial({ color: 0xDEA057, roughness: 0.6, metalness: 0.3 });
            const pattyMaterial = new THREE.MeshStandardMaterial({ color: 0x5C2E1A, roughness: 0.8, metalness: 0.2 });
            const lettuceMaterial = new THREE.MeshStandardMaterial({ color: 0x78A43D, roughness: 0.5, metalness: 0.1 });
            const tomatoMaterial = new THREE.MeshStandardMaterial({ color: 0xFF6347, roughness: 0.5, metalness: 0.1 });

            const topBun = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2), bunMaterial);
            topBun.position.y = 0.5;
            group.add(topBun);

            const bottomBun = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2), bunMaterial);
            bottomBun.position.y = -0.4;
            group.add(bottomBun);

            const patty = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.3, 32), pattyMaterial);
            patty.position.y = 0.1;
            group.add(patty);

            const lettuce = new THREE.Mesh(new THREE.CylinderGeometry(0.85, 0.85, 0.1, 32), lettuceMaterial);
            lettuce.position.y = 0.3;
            group.add(lettuce);

            const tomato = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 0.1, 32), tomatoMaterial);
            tomato.position.y = 0.4;
            group.add(tomato);

            // group.scale.copy(originalScale); // Scale will be applied based on FoodItem definition
            return group;
        }

        // Populate foodItems (after generateHamburgerModel is defined)
        foodItems['hamburger'] = new FoodItem(
            'hamburger',
            'Classic Burger',
            generateHamburgerModel,
            new THREE.Vector3(0.5, 0.5, 0.5),    // originalScale
            new THREE.Vector3(0.55, 0.55, 0.55), // hoverScale
            new THREE.Vector3(0.4, 0.4, 0.4)  // clickScale (adjusted)
        );

        function generatePizzaModel() {
            const group = new THREE.Group();
            const crustMaterial = new THREE.MeshStandardMaterial({ color: 0xE0C08A, roughness: 0.8, metalness: 0.2 });
            const sauceMaterial = new THREE.MeshStandardMaterial({ color: 0xBF3A30, roughness: 0.6, metalness: 0.1 });
            const pepperoniMaterial = new THREE.MeshStandardMaterial({ color: 0xC83E4D, roughness: 0.7, metalness: 0.2 });

            // Pizza slice shape (triangle from cylinder segment)
            const pizzaSliceShape = new THREE.Shape();
            const radius = 1.2;
            const angle = Math.PI / 3; // 60 degree slice
            pizzaSliceShape.moveTo(0, 0);
            pizzaSliceShape.arc(0, 0, radius, -angle / 2, angle / 2, false);
            pizzaSliceShape.lineTo(0, 0);

            const extrudeSettings = { depth: 0.15, bevelEnabled: false };
            const geometry = new THREE.ExtrudeGeometry(pizzaSliceShape, extrudeSettings);

            const base = new THREE.Mesh(geometry, crustMaterial);
            base.rotation.x = -Math.PI / 2; // Lay flat
            group.add(base);

            // Sauce (slightly smaller)
            const sauceShape = new THREE.Shape();
            sauceShape.moveTo(0, 0);
            sauceShape.arc(0, 0, radius * 0.9, -angle/2, angle/2, false);
            sauceShape.lineTo(0,0);
            const sauceExtrudeSettings = { depth: 0.05, bevelEnabled: false };
            const sauceGeometry = new THREE.ExtrudeGeometry(sauceShape, sauceExtrudeSettings);
            const sauce = new THREE.Mesh(sauceGeometry, sauceMaterial);
            sauce.rotation.x = -Math.PI / 2;
            sauce.position.y = 0.08; // Slightly above crust
            group.add(sauce);

            // Pepperonis
            const pepperoniRadius = 0.15;
            const pepperoniGeometry = new THREE.CylinderGeometry(pepperoniRadius, pepperoniRadius, 0.03, 16);
            for (let i = 0; i < 5; i++) {
                const pepperoni = new THREE.Mesh(pepperoniGeometry, pepperoniMaterial);
                // Randomly place on the slice area
                const r = Math.random() * radius * 0.7;
                const a = (Math.random() - 0.5) * angle * 0.9;
                pepperoni.position.set(r * Math.cos(a), 0.10, r * Math.sin(a)); // y is height on slice
                group.add(pepperoni);
            }
            group.rotation.y = -Math.PI / 6; // Orient tip forward
            return group;
        }

        foodItems['pizza'] = new FoodItem(
            'pizza',
            'Pepperoni Slice',
            generatePizzaModel,
            new THREE.Vector3(0.6, 0.6, 0.6),    // originalScale
            new THREE.Vector3(0.65, 0.65, 0.65), // hoverScale
            new THREE.Vector3(0.5, 0.5, 0.5)  // clickScale (adjusted)
        );

        function generateDonutModel() {
            const group = new THREE.Group();
            const donutMaterial = new THREE.MeshStandardMaterial({ color: 0xE6BF83, roughness: 0.7, metalness: 0.1 });
            const icingMaterial = new THREE.MeshStandardMaterial({ color: 0xFF69B4, roughness: 0.5, metalness: 0.2 }); // Pink icing
            const sprinkleColors = [0xFFFFFF, 0xADD8E6, 0x90EE90, 0xFFD700, 0xFFA07A]; // White, light blue, light green, gold, light salmon

            const torusRadius = 0.7;
            const tubeRadius = 0.3;
            const donutGeometry = new THREE.TorusGeometry(torusRadius, tubeRadius, 16, 32);
            const donut = new THREE.Mesh(donutGeometry, donutMaterial);
            donut.rotation.x = Math.PI / 2; // Lay flat
            group.add(donut);

            const icingGeometry = new THREE.TorusGeometry(torusRadius * 1.02, tubeRadius * 0.8, 16, 32, Math.PI); // Half a torus for icing on top
            const icing = new THREE.Mesh(icingGeometry, icingMaterial);
            icing.rotation.x = Math.PI/2; // Align with donut
            icing.position.y = tubeRadius * 0.1; // Slightly above donut
            group.add(icing);

            // Sprinkles
            const sprinkleGeometry = new THREE.BoxGeometry(0.05, 0.15, 0.05);
            for (let i = 0; i < 30; i++) {
                const sprinkleMaterial = new THREE.MeshStandardMaterial({ color: sprinkleColors[Math.floor(Math.random() * sprinkleColors.length)], roughness: 0.8 });
                const sprinkle = new THREE.Mesh(sprinkleGeometry, sprinkleMaterial);
                const angle = Math.random() * Math.PI; // Place on top half
                const r = torusRadius + (Math.random() - 0.5) * tubeRadius * 1.2; // Distribute around the torus shape
                sprinkle.position.set(
                    Math.cos(angle) * r,
                    tubeRadius * 0.7 + (Math.random() * 0.1), // On top of icing
                    Math.sin(angle) * r
                );
                sprinkle.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                group.add(sprinkle);
            }
            return group;
        }

        foodItems['donut'] = new FoodItem(
            'donut',
            'Sprinkled Donut',
            generateDonutModel,
            new THREE.Vector3(0.7, 0.7, 0.7),    // originalScale
            new THREE.Vector3(0.75, 0.75, 0.75), // hoverScale
            new THREE.Vector3(0.6, 0.6, 0.6)  // clickScale (adjusted)
        );
        // Add more food items here later

        /**
         * Creates a smaller version of the current food model for floating animations.
         * @returns {THREE.Group | null} The mini food model or null if main model doesn't exist.
         */
        function createMiniFoodModel() {
            if (!currentFoodModel) return null;
            const currentFoodItem = foodItems[currentFoodItemId];
            if (!currentFoodItem) {
                console.error("Current food item not found for mini model:", currentFoodItemId);
                return null;
            }

            const miniModel = currentFoodItem.modelGenerator(); // Generate a fresh model
            // Define a miniScale, perhaps on FoodItem or globally for mini particles
            miniModel.scale.set(0.1, 0.1, 0.1);

            miniModel.traverse(child => { // Changed miniBurger to miniModel
                if (child.isMesh) {
                    if (Array.isArray(child.material)) {
                        child.material = child.material.map(m => m.clone());
                    } else {
                        child.material = child.material.clone();
                    }
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                        mat.transparent = true;
                        mat.opacity = 1.0; // Initial opacity for mini models
                    });
                }
            });
            return miniModel; // Changed miniBurger to miniModel
        }

        /**
         * Positions the main food model in the center of the 'food-container' div.
         */
        function positionCurrentFoodModel() {
            if (!currentFoodModel || !camera) return;
            const foodContainer = document.getElementById('food-container');
            if (!foodContainer) return;

            const rect = foodContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const vec = new THREE.Vector3();
            const pos = new THREE.Vector3();
            vec.set( (centerX / window.innerWidth) * 2 - 1, -(centerY / window.innerHeight) * 2 + 1, 0.5 );
            vec.unproject(camera);
            vec.sub(camera.position).normalize();
            const distance = -camera.position.z / vec.z;
            pos.copy(camera.position).add(vec.multiplyScalar(distance));
            currentFoodModel.position.copy(pos);
            currentFoodModel.position.y -= 0.5; // Fine-tune vertical position
        }

        /**
         * Creates and distributes decorative 3D elements in the background.
         */
        function createBackgroundElements() {
            const geometries = [
                new THREE.SphereGeometry(1, 16, 16), new THREE.BoxGeometry(1, 1, 1),
                new THREE.ConeGeometry(1, 1.5, 16), new THREE.TorusKnotGeometry(1, 0.3, 100, 16)
            ];
            const materials = [
                new THREE.MeshStandardMaterial({ color: 0xff00ff, roughness: 0.5, metalness: 0.2 }), // Magenta
                new THREE.MeshStandardMaterial({ color: 0x00ffff, roughness: 0.5, metalness: 0.2 }), // Cyan
                new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.5, metalness: 0.2 }), // Yellow
                new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.5, metalness: 0.2 })  // Green
            ];

            for (let i = 0; i < 50; i++) {
                const geometry = geometries[Math.floor(Math.random() * geometries.length)];
                const material = materials[Math.floor(Math.random() * materials.length)].clone();
                material.transparent = true;
                material.opacity = 0.3 + Math.random() * 0.4;
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set( (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 50 - 20 );
                mesh.scale.setScalar(Math.random() * 2 + 0.5);
                mesh.rotation.set( Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2 );
                mesh.userData = {
                    isBackgroundElement: true,
                    rotationSpeed: { x: (Math.random() - 0.5) * 0.002, y: (Math.random() - 0.5) * 0.002 },
                    offset: Math.random() * Math.PI * 2
                };
                scene.add(mesh);
            }
        }

        /**
         * Handles window resize events to update camera and renderer.
         */
        function onWindowResize() {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            positionCurrentFoodModel(); // Reposition food model on resize
        }

        /**
         * Handles mouse move events for raycasting and hover effects.
         * @param {MouseEvent} event The mouse event.
         */
        function onMouseMove(event) {
            if(!mouse) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        /**
         * Handles click events on the Three.js canvas, primarily for interacting with the main food item.
         * @param {MouseEvent} event The mouse event.
         */
        function onThreeJSClick(event) { // Renamed from onClick
            if (!currentFoodModel || !raycaster || !camera || !scene) return;
            const currentFoodItem = foodItems[currentFoodItemId];
            if (!currentFoodItem) {
                console.error("Food item not found on click:", currentFoodItemId);
                return;
            }

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(currentFoodModel, true);

            if (intersects.length > 0) {
                addScore(multiplier); // addScore calls checkAchievements()

                // Track clicks for "clicksInSec" achievements
                const now = Date.now();
                clickTimestamps.push(now);
                clickTimestamps = clickTimestamps.filter(timestamp => now - timestamp < 1000);
                checkAchievements();

                // Create a floating 3D food particle effect from the click position
                createFloatingFoodParticle(
                    event.clientX, // Use direct mouse click coords for visual origin
                    event.clientY
                );

                // Click animation for the main food item
                const originalRotationX = currentFoodModel.rotation.x;
                const originalPositionY = currentFoodModel.position.y;

                currentFoodModel.scale.copy(currentFoodItem.clickScale);
                currentFoodModel.rotation.x -= 0.2; // Quick tilt
                currentFoodModel.position.y -= 0.05; // Quick dip

                setTimeout(() => {
                    currentFoodModel.scale.copy(isHovering ? currentFoodItem.hoverScale : currentFoodItem.originalScale);
                    currentFoodModel.rotation.x = originalRotationX; // Return to original tilt
                    currentFoodModel.position.y = originalPositionY; // Return to original dip
                    // The continuous rotation on Y-axis is handled by animateThreeJS and should not be reset here.
                }, 75); // Reduced timeout for snappier feel
            }
        }

        /**
         * The main animation loop for Three.js.
         */
        function animateThreeJS() {
            requestAnimationFrame(animateThreeJS);
            const delta = 0.016; // Approximate delta time (assuming ~60fps)

            // Main food item hover effect
            if (raycaster && currentFoodModel && scene && camera && renderer) {
                const currentFoodItem = foodItems[currentFoodItemId];
                if (currentFoodItem) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObject(currentFoodModel, true);
                    if (intersects.length > 0) {
                        if (!isHovering) { isHovering = true; currentFoodModel.scale.copy(currentFoodItem.hoverScale); }
                    } else {
                        if (isHovering) { isHovering = false; currentFoodModel.scale.copy(currentFoodItem.originalScale); }
                    }
                } else {
                     if (isHovering) { isHovering = false; } // Ensure isHovering is reset if item is missing
                }
            }

            if (currentFoodModel) currentFoodModel.rotation.y += 0.005; // Gentle continuous rotation

            // Animate background elements
            scene.traverse(child => {
                if (child.userData.isBackgroundElement) {
                    child.rotation.x += child.userData.rotationSpeed.x;
                    child.rotation.y += child.userData.rotationSpeed.y;
                    child.position.y += Math.sin(Date.now() * 0.0005 + child.userData.offset) * 0.005;
                }
            });

            // Animate floating 3D burgers
            for (let i = floatingBurgers3D.length - 1; i >= 0; i--) {
                const burgerData = floatingBurgers3D[i];
                const burgerMesh = burgerData.mesh;
                burgerMesh.position.y += burgerData.velocityY * delta;
                burgerMesh.position.x += burgerData.velocityX * delta;
                burgerMesh.rotation.x += burgerData.rotationSpeed * delta * 5;
                burgerMesh.rotation.y += burgerData.rotationSpeed * delta * 5;
                burgerData.life -= delta;

                burgerMesh.traverse(subChild => { // Fade out
                    if (subChild.isMesh && subChild.material) {
                        if (!subChild.material.transparent) subChild.material.transparent = true;
                        subChild.material.opacity = Math.max(0, burgerData.life / burgerData.initialLife);
                    }
                });

                if (burgerData.life <= 0) { // Cleanup
                    scene.remove(burgerMesh);
                    burgerMesh.traverse(subChild => {
                        if (subChild.isMesh) {
                            if(subChild.geometry) subChild.geometry.dispose();
                            if(subChild.material) {
                                (Array.isArray(subChild.material) ? subChild.material : [subChild.material]).forEach(m => m.dispose());
                            }
                        }
                    });
                    floatingBurgers3D.splice(i, 1);
                }
            }
            if (scene && camera && renderer) renderer.render(scene, camera);
        }

        // --- CORE GAME LOGIC ---

        /**
         * Adds to the player's score and updates related UI elements.
         * @param {number} amount The amount to add to the score.
         */
        function addScore(amount) {
            score += amount;
            elements.score.textContent = formatNumber(score);
            checkRank();
            checkAchievements();
            updateRankProgress();
        }

        /**
         * Formats a number into a human-readable string (K for thousands, M for millions).
         * @param {number} num The number to format.
         * @returns {string} The formatted number string.
         */
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        }

        /**
         * Creates a 3D floating food particle animation starting from screen coordinates.
         * @param {number} screenX The X screen coordinate.
         * @param {number} screenY The Y screen coordinate.
         */
        const loggedFloatingParticles = {}; // Helper to log once per food type for createFloatingFoodParticle
        function createFloatingFoodParticle(screenX, screenY) {
            if (!loggedFloatingParticles[currentFoodItemId]) {
                console.log(`Creating floating particle for: ${currentFoodItemId}`);
                loggedFloatingParticles[currentFoodItemId] = true;
            }
            const miniFoodMesh = createMiniFoodModel();
            if (!miniFoodMesh || !scene || !camera || !currentFoodModel) return;

            const startPos = new THREE.Vector3();
            // Convert screen click to world coordinates near the main food model's surface
            const vec = new THREE.Vector3( (screenX / window.innerWidth) * 2 - 1, -(screenY / window.innerHeight) * 2 + 1, 0.5);
            vec.unproject(camera);
            // Place it slightly in front of the camera, then move towards the unprojected point at an estimated depth of the food model
            const dir = vec.sub(camera.position).normalize();
            const distance = currentFoodModel.position.distanceTo(camera.position) * 0.8; // Estimate distance to food model surface from camera
            startPos.copy(camera.position).add(dir.multiplyScalar(distance));

            miniFoodMesh.position.copy(startPos);
            scene.add(miniFoodMesh);

            const initialLifeTime = 1.0 + Math.random() * 0.5;
            floatingBurgers3D.push({
                mesh: miniFoodMesh,
                velocityX: (Math.random() - 0.5) * 2.5,
                velocityY: 2.5 + Math.random() * 1.5,
                rotationSpeed: (Math.random() - 0.5) * 6,
                life: initialLifeTime,
                initialLife: initialLifeTime
            });
        }

        /**
         * Updates the player's rank based on their score.
         */
        function checkRank() {
            for (let i = ranks.length - 1; i >= 0; i--) {
                if (score >= ranks[i].requirement) {
                    if (elements.rankName.textContent !== ranks[i].name) {
                        elements.rankName.textContent = ranks[i].name;
                        elements.rankName.classList.add('level-up');
                        setTimeout(() => elements.rankName.classList.remove('level-up'), 1000);
                    }
                    break;
                }
            }
        }

        /**
         * Updates the visual progress bar for the current rank.
         */
        function updateRankProgress() {
            let currentRank = ranks[0];
            let nextRank = null;
            for (let i = 0; i < ranks.length; i++) {
                if (score >= ranks[i].requirement) {
                    currentRank = ranks[i];
                    if (i < ranks.length - 1) nextRank = ranks[i+1];
                } else {
                    if (!nextRank) nextRank = ranks[i]; // Handles case where player is below first rank with requirement > 0
                    break;
                }
            }

            if (nextRank && currentRank.name !== nextRank.name) { // Ensure not trying to divide by zero if current = next
                const progress = Math.min(100, ((score - currentRank.requirement) / (nextRank.requirement - currentRank.requirement)) * 100);
                elements.rankProgress.style.width = `${progress}%`;
                elements.rankProgress.setAttribute('aria-valuenow', progress);
            } else if (score >= currentRank.requirement && !nextRank) { // Max rank
                elements.rankProgress.style.width = '100%';
            } else { // Should not happen often, default to 0 or some initial state
                 elements.rankProgress.style.width = '0%';
            }
        }

        /**
         * Creates or removes visual elements representing auto-clickers. (Currently 2D)
         */
        function createAutoClickerVisual() { // This is still the 2D version
            const visual = document.createElement('img');
            visual.src = 'https://em-content.zobj.net/thumbs/120/apple/325/hamburger_1f354.png';
            visual.className = 'auto-clicker-visual';
            visual.style.transform = `rotate(${Math.random() * 360}deg)`;
            elements.foodContainer.appendChild(visual);
            setTimeout(() => visual.remove(), 3000);
        }
        function updateAutoClickerVisuals() { // This is still the 2D version
            const existingVisuals = document.querySelectorAll('.auto-clicker-visual');
            if (existingVisuals.length > autoClickerCount) {
                for (let i = autoClickerCount; i < existingVisuals.length; i++) existingVisuals[i].remove();
            } else {
                for (let i = existingVisuals.length; i < autoClickerCount; i++) createAutoClickerVisual();
            }
        }


        // --- ACHIEVEMENTS ---

        /**
         * Checks all defined achievements against current game state and unlocks them if criteria are met.
         */
        function checkAchievements() {
            achievements.forEach(achievement => {
                if (!achievement.unlocked) {
                    let unlockedThisCheck = false;
                    // Standard achievement types
                    if (achievement.type === "autoClicker" && autoClickerCount >= achievement.requirement) unlockedThisCheck = true;
                    else if (achievement.type === "autoSpeed" && autoSpeedLevel >= achievement.requirement) unlockedThisCheck = true;
                    else if (achievement.type === "clickPower" && multiplier >= achievement.requirement) unlockedThisCheck = true;
                    else if (achievement.type === "scorePrecision" && score === achievement.requirement) unlockedThisCheck = true;
                    else if (achievement.type === "clicksInSec" && clickTimestamps.length >= achievement.requirement) unlockedThisCheck = true;
                    else if (achievement.type === "timeOfDay") {
                        const currentHour = new Date().getHours();
                        if (currentHour >= 5 && currentHour < 7) unlockedThisCheck = true;
                    } else if ((!achievement.type || achievement.category === "milestone") && score >= achievement.requirement && achievement.requirement !== null && !achievement.requirementType) {
                        unlockedThisCheck = true;
                    }
                    // New achievement types
                    else if (achievement.requirementType === "foodSelected" && currentFoodItemId === achievement.foodId) {
                        unlockedThisCheck = true;
                    } else if (achievement.requirementType === "allFoodsSelected") {
                        const totalFoodItemTypes = Object.keys(foodItems).length;
                        if (unlockedFoodIds.length >= totalFoodItemTypes) {
                            unlockedThisCheck = true;
                        }
                    }

                    if (unlockedThisCheck) {
                        achievement.unlocked = true;
                        showAchievement(achievement.name);
                    }
                }
            });
        }

        /**
         * Displays an achievement notification.
         * @param {string} achievementName The name of the achievement to display.
         */
        function showAchievement(achievementName) {
            console.log(`Achievement Unlocked: ${achievementName}`);
            const alertEl = elements.achievementAlert;
            // The icon 'üèÜ' is added via CSS ::before pseudo-element.
            // This updates the text node part of the alert.
            alertEl.childNodes[alertEl.childNodes.length -1].nodeValue = ` Achievement Unlocked: ${achievementName} üéâ`;
            alertEl.classList.remove('d-none');

            // Force animation reset
            alertEl.style.animation = 'none';
            alertEl.offsetHeight; /* Trigger reflow */
            alertEl.style.animation = '';
            alertEl.style.animation = `slideInEnhanced 0.6s cubic-bezier(0.25, 0.8, 0.25, 1) forwards, pulseAchievement 1.8s infinite 0.7s`;

            setTimeout(() => {
                alertEl.classList.add('d-none');
                alertEl.style.animation = 'none'; // Stop animations when hidden
            }, 4000);
        }

        // --- LOCAL STORAGE (SAVE/LOAD) ---

        /**
         * Saves the current game state to local storage.
         */
        function saveGame() {
            const gameData = {
                score, multiplier, multiplierCost,
                autoClickerCount, autoClickerCost,
                autoSpeedLevel, autoSpeedCost,
                achievements, // Save the whole achievements array (including unlocked status)
                currentFoodItemId, // Save the current food item
                unlockedFoodIds // Save the list of unlocked food IDs
            };
            localStorage.setItem('minjiglesSimulator', JSON.stringify(gameData));
            lastSave = Date.now();
            // console.log("Game saved!"); // Optional: for debugging
        }

        /**
         * Loads game state from local storage.
         */
        function loadGame() {
            const savedData = localStorage.getItem('minjiglesSimulator');
            if (savedData) {
                const gameData = JSON.parse(savedData);
                score = gameData.score || 0;
                multiplier = gameData.multiplier || 1;
                multiplierCost = gameData.multiplierCost || 10;
                autoClickerCount = gameData.autoClickerCount || 0;
                autoClickerCost = gameData.autoClickerCost || 50;
                autoSpeedLevel = gameData.autoSpeedLevel || 1;
                autoSpeedCost = gameData.autoSpeedCost || 100;
                currentFoodItemId = gameData.currentFoodItemId || 'hamburger'; // Load current food item, default to hamburger
                unlockedFoodIds = gameData.unlockedFoodIds || []; // Load unlocked food IDs

                // Merge loaded achievements with current ones to preserve new definitions
                // while restoring unlocked status
                if (gameData.achievements) {
                    gameData.achievements.forEach(savedAch => {
                        const currentAch = achievements.find(a => a.name === savedAch.name);
                        if (currentAch) {
                            currentAch.unlocked = savedAch.unlocked;
                        }
                    });
                }

                // Update UI based on loaded data
                elements.score.textContent = formatNumber(score);
                elements.multiplier.textContent = multiplier;
                elements.clickPower.textContent = multiplier;
                elements.mps.textContent = formatNumber(autoClickerCount * autoSpeedLevel);
                elements.multiplierUpgradeBtn.textContent = `Upgrade Click Power (Cost: ${formatNumber(multiplierCost)})`;
                elements.autoClickerBtn.textContent = `Buy Auto Clicker (Cost: ${formatNumber(autoClickerCost)})`;
                elements.autoSpeedBtn.textContent = `Upgrade Speed (Cost: ${formatNumber(autoSpeedCost)})`;
                elements.autoCount.textContent = autoClickerCount;
                elements.autoSpeedLevel.textContent = autoSpeedLevel;

                checkRank();
                updateRankProgress();
                updateAutoClickerVisuals(); // For 2D auto clicker visuals
            }
        }

        // --- INITIALIZATION & EVENT LISTENERS ---

        // Parallax Hover Effect for Stats and Upgrades containers
        const parallaxContainers = document.querySelectorAll('.stats-container, .upgrades-container');
        parallaxContainers.forEach(container => {
            container.addEventListener('mousemove', (e) => {
                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                const {width, height} = rect;
                const rotateY = ((x - width / 2) / (width / 2)) * 7; // Max 7 deg
                const rotateX = -((y - height / 2) / (height / 2)) * 7; // Max 7 deg
                container.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            });
            container.addEventListener('mouseleave', () => {
                container.style.transform = 'perspective(1000px) rotateX(0) rotateY(0)';
            });
        });

        // Event listener for the multiplier upgrade button
        elements.multiplierUpgradeBtn.addEventListener('click', () => {
            if (score >= multiplierCost) {
                score -= multiplierCost;
                multiplier++;
                multiplierCost = Math.floor(multiplierCost * 1.5);
                elements.score.textContent = formatNumber(score);
                elements.multiplier.textContent = multiplier;
                elements.clickPower.textContent = multiplier;
                elements.multiplierUpgradeBtn.textContent = `Upgrade Click Power (Cost: ${formatNumber(multiplierCost)})`;
                elements.multiplier.classList.add('sparkle');
                setTimeout(() => elements.multiplier.classList.remove('sparkle'), 1000);
                checkAchievements();
            }
        });

        // Event listener for the auto-clicker purchase button
        elements.autoClickerBtn.addEventListener('click', () => {
            if (score >= autoClickerCost) {
                score -= autoClickerCost;
                autoClickerCount++;
                autoClickerCost = Math.floor(autoClickerCost * 1.8);
                elements.score.textContent = formatNumber(score);
                elements.autoClickerBtn.textContent = `Buy Auto Clicker (Cost: ${formatNumber(autoClickerCost)})`;
                elements.mps.textContent = formatNumber(autoClickerCount * autoSpeedLevel);
                elements.autoCount.textContent = autoClickerCount;
                updateAutoClickerVisuals(); // For 2D visuals
                checkAchievements();
            }
        });

        // Event listener for the auto-clicker speed upgrade button
        elements.autoSpeedBtn.addEventListener('click', () => {
            if (score >= autoSpeedCost) {
                score -= autoSpeedCost;
                autoSpeedLevel++;
                autoSpeedCost = Math.floor(autoSpeedCost * 2);
                elements.score.textContent = formatNumber(score);
                elements.autoSpeedBtn.textContent = `Upgrade Speed (Cost: ${formatNumber(autoSpeedCost)})`;
                elements.mps.textContent = formatNumber(autoClickerCount * autoSpeedLevel);
                elements.autoSpeedLevel.textContent = autoSpeedLevel;
                checkAchievements();
            }
        });

        // Auto-save interval (every 30 seconds)
        setInterval(saveGame, 30000);
        // Save game when the window is about to be unloaded
        window.onbeforeunload = saveGame;

        // Event listener for food selection buttons
        document.querySelectorAll('.food-select-btn').forEach(button => {
            button.addEventListener('click', () => {
                const newFoodId = button.getAttribute('data-foodid');
                if (newFoodId === currentFoodItemId) return; // No change if already selected

                // Dispose and remove old model
                if (currentFoodModel) {
                    currentFoodModel.traverse(child => {
                        if (child.isMesh) {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        }
                    });
                    scene.remove(currentFoodModel);
                }

                currentFoodItemId = newFoodId;
                const newFoodItem = foodItems[currentFoodItemId];

                if (!newFoodItem) {
                    console.error("Selected food item not found:", currentFoodItemId);
                    // Optionally revert to a default or handle error
                    return;
                }

                // Create and add new model
                currentFoodModel = newFoodItem.modelGenerator();
                currentFoodModel.scale.copy(newFoodItem.originalScale);
                scene.add(currentFoodModel);
                positionCurrentFoodModel();
                isHovering = false; // Reset hover state

                // Update button active states
                document.querySelectorAll('.food-select-btn').forEach(btn => {
                    btn.classList.remove('btn-primary'); // Assuming primary is active
                    btn.classList.add('btn-secondary');
                });
                button.classList.remove('btn-secondary');
                button.classList.add('btn-primary');

                // Track unlocked food items for achievements
                if (!unlockedFoodIds.includes(currentFoodItemId)) {
                    unlockedFoodIds.push(currentFoodItemId);
                }
                console.log(`Switched to food: ${currentFoodItemId}`);
                console.log(`Unlocked food items: ${unlockedFoodIds.join(', ')}`);
                checkAchievements(); // Check achievements after changing food and updating unlockedFoodIds
                saveGame();
            });
        });

        // Auto-clicker interval (adds score every second based on auto-clickers owned and their speed)
        setInterval(() => {
            if (autoClickerCount > 0 && currentFoodModel && camera && scene) {
                addScore(autoClickerCount * autoSpeedLevel); // addScore calls checkAchievements

                // Create a floating 3D food particle originating from the main food model for auto-clicks
                const screenPosVec = new THREE.Vector3();
                currentFoodModel.getWorldPosition(screenPosVec);
                screenPosVec.project(camera);
                const screenX = (screenPosVec.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-screenPosVec.y * 0.5 + 0.5) * window.innerHeight;
                const currentFoodItem = foodItems[currentFoodItemId];
                const modelScaleX = currentFoodItem ? currentFoodItem.originalScale.x : 0.5; // fallback scale
                const modelScaleY = currentFoodItem ? currentFoodItem.originalScale.y : 0.5; // fallback scale
                const randomOffsetX = (Math.random() - 0.5) * (modelScaleX * 100);
                const randomOffsetY = (Math.random() - 0.5) * (modelScaleY * 100);
                createFloatingFoodParticle(screenX + randomOffsetX, screenY + randomOffsetY);
            }
        }, 1000);

        // Initialize the game
        loadGame();    // Load saved state first
        initThreeJS(); // Then initialize Three.js

        // After initThreeJS, update food selection button appearance
        const activeButton = document.querySelector(`.food-select-btn[data-foodid="${currentFoodItemId}"]`);
        if (activeButton) {
            document.querySelectorAll('.food-select-btn').forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            });
            activeButton.classList.remove('btn-secondary');
            activeButton.classList.add('btn-primary');
        }

        animateThreeJS(); // Start the animation loop
        updateRankProgress(); // Initial rank progress update
        checkAchievements(); // Check for any initially met time-based achievements etc.

        function runAutomatedTests() {
            console.log("--- Starting Automated Tests ---");

            // Helper to simulate food selection click logic directly
            // This avoids issues with DOM elements not being fully ready or event propagation complexities in a test script
            function selectFoodItemProgrammatically(foodId) {
                console.log(`\n[TEST] Programmatically selecting: ${foodId}`);
                if (foodId === currentFoodItemId) {
                    console.log(`[TEST] Food ${foodId} is already selected.`);
                    return;
                }

                if (currentFoodModel) {
                    currentFoodModel.traverse(child => {
                        if (child.isMesh) {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        }
                    });
                    scene.remove(currentFoodModel);
                }

                currentFoodItemId = foodId;
                const newFoodItem = foodItems[currentFoodItemId];

                if (!newFoodItem) {
                    console.error(`[TEST_ERROR] Selected food item not found in foodItems: ${currentFoodItemId}`);
                    return;
                }

                currentFoodModel = newFoodItem.modelGenerator();
                currentFoodModel.scale.copy(newFoodItem.originalScale);
                scene.add(currentFoodModel);
                positionCurrentFoodModel();
                isHovering = false;

                document.querySelectorAll('.food-select-btn').forEach(btn => {
                    btn.classList.remove('btn-primary'); btn.classList.add('btn-secondary');
                });
                const activeButton = document.querySelector(`.food-select-btn[data-foodid="${currentFoodItemId}"]`);
                if (activeButton) {
                    activeButton.classList.remove('btn-secondary'); activeButton.classList.add('btn-primary');
                }

                if (!unlockedFoodIds.includes(currentFoodItemId)) {
                    unlockedFoodIds.push(currentFoodItemId);
                }
                // The actual game logs these, so we don't need to repeat here if we call checkAchievements
                // console.log(`Switched to food: ${currentFoodItemId}`);
                // console.log(`Unlocked food items: ${unlockedFoodIds.join(', ')}`);
                checkAchievements();
                // saveGame(); // saveGame will be tested separately
            }

            // Helper to get achievement status
            function getAchievementStatus(name) {
                const ach = achievements.find(a => a.name === name);
                return ach ? ach.unlocked : 'Not Found';
            }

            // --- Pre-Test State Reset ---
            console.log("\n--- Pre-Test State Reset ---");
            // Reset achievements that will be tested
            achievements.forEach(ach => {
                if (ach.name === "Pizza Time!" || ach.name === "Donut Delight!" || ach.name === "Food Connoisseur") {
                    ach.unlocked = false;
                }
            });
            unlockedFoodIds = []; // Clear unlocked food IDs
            // Set a known starting food item
            selectFoodItemProgrammatically('hamburger'); // Start with hamburger, this will add 'hamburger' to unlockedFoodIds
             // Manually clear the loggedFloatingParticles for fresh particle logging
            for (const key in loggedFloatingParticles) { delete loggedFloatingParticles[key]; }


            // 1. Test Food Switching and Model Updates
            console.log("\n--- Test: Food Switching & Model Updates ---");
            console.log(`Initial currentFoodItemId: ${currentFoodItemId}, Model Name: ${foodItems[currentFoodItemId] ? foodItems[currentFoodItemId].name : 'N/A'}`);

            selectFoodItemProgrammatically('pizza');
            console.log(`After switching to Pizza -> currentFoodItemId: ${currentFoodItemId}, Model Name: ${foodItems[currentFoodItemId] ? foodItems[currentFoodItemId].name : 'N/A'}`);
            if (currentFoodItemId !== 'pizza') console.error("[FAIL] currentFoodItemId not updated to pizza.");
            if (!unlockedFoodIds.includes('pizza')) console.error("[FAIL] unlockedFoodIds does not include pizza.");

            selectFoodItemProgrammatically('donut');
            console.log(`After switching to Donut -> currentFoodItemId: ${currentFoodItemId}, Model Name: ${foodItems[currentFoodItemId] ? foodItems[currentFoodItemId].name : 'N/A'}`);
            if (currentFoodItemId !== 'donut') console.error("[FAIL] currentFoodItemId not updated to donut.");
            if (!unlockedFoodIds.includes('donut')) console.error("[FAIL] unlockedFoodIds does not include donut.");

            // Note: hamburger was already selected during pre-test reset
            console.log(`Current unlockedFoodIds before checking 'Food Connoisseur': ${unlockedFoodIds.join(', ')}`);


            // 2. Test Achievement Unlocking Logic
            console.log("\n--- Test: Achievement Unlocking ---");
            // Achievements are checked by selectFoodItemProgrammatically via checkAchievements()
            console.log(`'Pizza Time!' unlocked: ${getAchievementStatus("Pizza Time!")}`);
            if (!getAchievementStatus("Pizza Time!")) console.error("[FAIL] 'Pizza Time!' should be unlocked.");

            console.log(`'Donut Delight!' unlocked: ${getAchievementStatus("Donut Delight!")}`);
            if (!getAchievementStatus("Donut Delight!")) console.error("[FAIL] 'Donut Delight!' should be unlocked.");

            console.log(`'Food Connoisseur' unlocked: ${getAchievementStatus("Food Connoisseur")}`);
            // Check if all foods (hamburger, pizza, donut) are in unlockedFoodIds
            const allFoods = ['hamburger', 'pizza', 'donut'];
            const allPresent = allFoods.every(food => unlockedFoodIds.includes(food));
            if (allPresent) {
                if (!getAchievementStatus("Food Connoisseur")) console.error("[FAIL] 'Food Connoisseur' should be unlocked as all foods were selected.");
            } else {
                 console.warn("[INFO] 'Food Connoisseur' not unlocked, not all foods were registered in unlockedFoodIds. Current: " + unlockedFoodIds.join(','));
            }


            // 3. Test Save/Load for Selected Food & UI Button State
            console.log("\n--- Test: Save/Load for Selected Food & UI ---");
            // currentFoodItemId is 'donut' from previous step. unlockedFoodIds contains hamburger, pizza, donut.
            saveGame(); // Save with 'donut' and all three in unlockedFoodIds
            console.log("Game saved with currentFoodItemId = donut, unlockedFoodIds = " + unlockedFoodIds.join(', '));

            // Simulate a reset before load
            let originalFoodItemIdBeforeLoad = currentFoodItemId;
            currentFoodItemId = 'hamburger'; // Reset to default
            unlockedFoodIds = []; // Clear unlockedFoodIds to ensure it loads correctly
            console.log("Simulated reset: currentFoodItemId = hamburger, unlockedFoodIds = []");

            loadGame(); // This should load 'donut' and the full unlockedFoodIds
            console.log(`After loadGame(), currentFoodItemId: ${currentFoodItemId}`);
            console.log(`After loadGame(), unlockedFoodIds: ${unlockedFoodIds.join(', ')}`);

            if (currentFoodItemId !== 'donut') console.error(`[FAIL] currentFoodItemId not loaded as 'donut'. Loaded: ${currentFoodItemId}`);
            if (unlockedFoodIds.length !== 3 || !unlockedFoodIds.includes('donut') || !unlockedFoodIds.includes('pizza') || !unlockedFoodIds.includes('hamburger')) {
                console.error(`[FAIL] unlockedFoodIds not loaded correctly. Loaded: ${unlockedFoodIds.join(', ')}`);
            }

            // Verify UI button for 'donut' is active (after a full init cycle post-load)
            // This simulates the main game flow's initialization for UI updates
            if (currentFoodModel) {
                currentFoodModel.traverse(child => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) { (Array.isArray(child.material) ? child.material : [child.material]).forEach(m => m.dispose()); }
                    }
                });
                scene.remove(currentFoodModel);
            }
            // Re-initialize model based on loaded currentFoodItemId
            const foodItemAfterLoad = foodItems[currentFoodItemId];
            if (foodItemAfterLoad) {
                currentFoodModel = foodItemAfterLoad.modelGenerator();
                currentFoodModel.scale.copy(foodItemAfterLoad.originalScale);
                scene.add(currentFoodModel);
                positionCurrentFoodModel();
                isHovering = false; // Reset hover state

                // Update button active states based on loaded currentFoodItemId
                document.querySelectorAll('.food-select-btn').forEach(btn => {
                    btn.classList.remove('btn-primary'); btn.classList.add('btn-secondary');
                });
                const activeButtonAfterLoad = document.querySelector(`.food-select-btn[data-foodid="${currentFoodItemId}"]`);
                if (activeButtonAfterLoad) {
                    activeButtonAfterLoad.classList.remove('btn-secondary'); activeButtonAfterLoad.classList.add('btn-primary');
                    console.log(`UI Button for ${currentFoodItemId} should now be active.`);
                    if (!activeButtonAfterLoad.classList.contains('btn-primary')) {
                         console.error(`[FAIL] UI button for ${currentFoodItemId} is not active after load and UI update.`);
                    }
                } else {
                     console.error(`[FAIL] Could not find button for ${currentFoodItemId} to check active state.`);
                }
            } else {
                console.error("[TEST_ERROR] Could not re-initialize model for UI button check as foodItemAfterLoad is null for ID: " + currentFoodItemId);
            }

            // Simulate one click to check floating particle logging for the loaded item
            console.log("\n--- Test: Floating Particle Logging for Loaded Item ---");
            if (currentFoodModel) { // Check if model exists
                 // Manually clear the loggedFloatingParticles for this specific test
                for (const key in loggedFloatingParticles) { delete loggedFloatingParticles[key]; }
                createFloatingFoodParticle(window.innerWidth / 2, window.innerHeight / 2); // Simulate a click effect
            } else {
                console.error("[TEST_ERROR] No currentFoodModel to test floating particle generation.");
            }


            console.log("\n--- Automated Tests Finished ---");
        }

        // Call the test function after all initializations
        runAutomatedTests();

    </script>
</body>
</html>
