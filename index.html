<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mingle my jingles!</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .food-img {
            width: 200px;
            height: 200px;
            cursor: pointer;
            transition: transform 0.1s;
            user-select: none;
            -webkit-user-drag: none;
        }

        .food-img:active {
            transform: scale(0.95);
        }

        .bounce {
            animation: bounce 0.5s;
        }

        .mini-burger { /* This class is no longer used for 3D floating burgers */
            position: absolute;
            width: 30px;
            height: 30px;
            pointer-events: none;
            animation: floatUp 1s forwards;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }

        @keyframes bounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .food-container {
            min-height: 220px;
            position: relative;
        }

        .stats-container, .upgrades-container {
            background-color: rgba(0, 0, 0, 0.25); /* Darker semi-transparent background */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); /* For Safari */
            padding: 20px;
            border-radius: 15px; /* Softer radius */
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* Adjusted shadow */
            border: 1px solid rgba(255, 255, 255, 0.15); /* Subtle edge */
            color: #f0f0f0; /* Ensure text is light and legible */
            transition: transform 0.1s ease-out; /* For parallax effect */
        }

        #achievement-alert {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1050; /* Ensure it's above most other elements, Bootstrap modals are 1050+ */
            width: 380px; /* Increased width */
            padding: 20px 25px; /* Increased padding */
            background: linear-gradient(145deg, #f8e076, #dfbe53); /* Gold gradient */
            color: #4A3B00; /* Darker gold/brown text for contrast */
            border: 2px solid #c8a840; /* Gold border */
            border-radius: 12px; /* Softer corners */
            box-shadow: 0 8px 25px rgba(0,0,0,0.35); /* More pronounced shadow */
            font-size: 1.15em; /* Slightly larger font */
            font-weight: bold;
            display: flex; /* For aligning icon and text */
            align-items: center; /* Align icon and text vertically */
            animation: slideInEnhanced 0.6s cubic-bezier(0.25, 0.8, 0.25, 1) forwards,
                       pulseAchievement 1.8s infinite 0.7s; /* New entry and pulse animation */
            transform: translateX(110%); /* Initial off-screen state for animation */
            opacity: 0; /* Initial hidden state for animation */
        }

        #achievement-alert.d-none { /* Ensure it's properly hidden when d-none is active */
            display: none !important; /* Override flex if d-none is added */
        }

        #achievement-alert::before {
            content: 'üèÜ'; /* Trophy icon */
            font-size: 1.8em; /* Larger icon */
            margin-right: 15px; /* Space between icon and text */
            line-height: 1; /* Ensure icon aligns well */
        }

        .auto-clicker-visual {
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            animation: rotate 3s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg) translateX(100px) rotate(0deg); }
            to { transform: rotate(360deg) translateX(100px) rotate(-360deg); }
        }

        /* Progress Bar Container Styling */
        .progress {
            height: 30px; /* Increased height */
            border-radius: 15px; /* Rounded ends */
            background-color: rgba(0, 0, 0, 0.3); /* Dark, slightly transparent background */
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.4); /* Inner shadow for depressed look */
            padding: 3px; /* Add a little padding so the bar inside doesn't touch edges */
        }

        /* Progress Bar Fill Styling */
        .progress-bar {
            border-radius: 12px; /* Rounded to fit neatly inside the container's padding */
            background-image: linear-gradient(45deg, #28a745, #218838); /* More vibrant gradient for success (default green) */
            box-shadow: 0 0 5px rgba(40, 167, 69, 0.7), 0 0 10px rgba(40, 167, 69, 0.5); /* Glow effect for the bar */
            /* The .progress-bar-striped and .progress-bar-animated classes from Bootstrap will still apply */
        }

        /* Ensuring other Bootstrap progress bar variants would also look good if used */
        .progress-bar.bg-info { /* Example for .bg-info if it were used for rank */
             background-image: linear-gradient(45deg, #17a2b8, #138496);
             box-shadow: 0 0 5px rgba(23, 162, 184, 0.7), 0 0 10px rgba(23, 162, 184, 0.5);
        }
        .progress-bar.bg-warning {
             background-image: linear-gradient(45deg, #ffc107, #e0a800);
             box-shadow: 0 0 5px rgba(255, 193, 7, 0.7), 0 0 10px rgba(255, 193, 7, 0.5);
        }
         .progress-bar.bg-primary { /* Rank progress uses default (blueish) in this game */
             background-image: linear-gradient(45deg, #007bff, #0069d9);
             box-shadow: 0 0 5px rgba(0, 123, 255, 0.7), 0 0 10px rgba(0, 123, 255, 0.5);
        }


        /* General Button Styling */
        .btn {
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out, transform 0.15s ease-in-out;
            font-weight: 500; /* Slightly bolder text */
        }

        .btn:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transform: translateY(-1px); /* Slight lift */
        }

        .btn:active {
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transform: translateY(1px); /* Press down effect */
        }

        /* Specific Button Colors (adjusting shades slightly if needed, keeping originals for now) */
        /* .btn-success (used by #multiplier-upgrade) - Bootstrap default is fine or can be overridden */
        /* .btn-info (used by #auto-clicker) - Bootstrap default is fine or can be overridden */
        /* .btn-warning (used by #auto-speed) - Bootstrap default is fine or can be overridden */


        .upgrade-card {
            background-color: rgba(0, 0, 0, 0.2); /* Consistent with new container backgrounds */
            border-radius: 12px; /* Softer and consistent */
            padding: 20px; /* More padding */
            margin-bottom: 15px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.15); /* Refined shadow */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }

        .upgrade-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.25); /* Enhanced shadow on hover */
        }

        .upgrade-card h5 { /* Ensure heading text is bright */
            color: #e9ecef;
        }
        .upgrade-card small { /* Ensure small text is bright */
            color: #adb5bd;
        }


        @keyframes slideIn { /* Original slideIn, modified slightly by enhancement to alert */
            from { transform: translateX(100%); }
            to { transform: translateX(0) scale(1); opacity: 1; }
        }

        @keyframes slideInEnhanced {
            0% { transform: translateX(110%) scale(0.8); opacity: 0; }
            30% { transform: translateX(110%) scale(0.8); opacity: 0; } /* Optional delay before moving */
            80% { transform: translateX(-5%) scale(1.05); opacity: 1; } /* Overshoot and bounce */
            100% { transform: translateX(0) scale(1); opacity: 1; }
        }

        @keyframes pulseAchievement {
            0% { box-shadow: 0 8px 25px rgba(0,0,0,0.35), 0 0 0 0 rgba(223, 190, 83, 0.7); }
            50% { box-shadow: 0 8px 30px rgba(0,0,0,0.45), 0 0 10px 15px rgba(223, 190, 83, 0); }
            100% { box-shadow: 0 8px 25px rgba(0,0,0,0.35), 0 0 0 0 rgba(223, 190, 83, 0); }
        }

        .sparkle {
            animation: sparkle 1s infinite;
        }

        @keyframes sparkle {
            0% { filter: brightness(100%); }
            50% { filter: brightness(150%); }
            100% { filter: brightness(100%); }
        }

        .level-up {
            animation: levelUp 1s;
        }

        @keyframes levelUp {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); color: #ffd700; }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-dark text-light">
    <div id="threejs-container" style="position: absolute; z-index: -1; top: 0; left: 0; width: 100%; height: 100%;"></div>
    <div class="container mt-5 text-center">
        <h1 class="mb-4 text-warning">üçî Bingle Jingle Simulingle's üçî</h1>
        
        <div class="stats-container mb-4">
            <h3>Rank: <span id="rank-name" class="text-info">Newbie Foodie</span></h3>
            <h4>Total Pounds: <span id="score" class="text-success">0</span></h4>
            <div class="progress mb-2">
                <div id="rank-progress" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
            </div>
            <h4>Pounds per Second: <span id="mps" class="text-primary">0</span></h4>
            <h5>Pounds per Click: <span id="multiplier" class="text-warning">1</span></h5>
        </div>

        <div class="food-container mb-4" id="food-container">
            <!-- <img src="https://em-content.zobj.net/thumbs/120/apple/325/hamburger_1f354.png"
                 id="food-btn" 
                 class="food-img"
                 alt="Click me!"> -->
        </div>

        <div class="upgrades-container">
            <h3 class="mb-3 text-warning">Upgrades</h3>
            <div class="row justify-content-center g-3">
                <div class="col-md-4">
                    <div class="upgrade-card">
                        <h5 class="text-info">Click Power</h5>
                        <button id="multiplier-upgrade" class="btn btn-success mb-2 w-100">
                            Upgrade Power (Cost: 10)
                        </button>
                        <small class="text-muted">Current: <span id="click-power">1</span> per click</small>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="upgrade-card">
                        <h5 class="text-info">Auto Clicker</h5>
                        <button id="auto-clicker" class="btn btn-info mb-2 w-100">
                            Buy Auto Clicker (Cost: 50)
                        </button>
                        <small class="text-muted">Owned: <span id="auto-count">0</span></small>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="upgrade-card">
                        <h5 class="text-info">Auto Speed</h5>
                        <button id="auto-speed" class="btn btn-warning mb-2 w-100">
                            Upgrade Speed (Cost: 100)
                        </button>
                        <small class="text-muted">Speed: <span id="auto-speed-level">1</span>x</small>
                    </div>
                </div>
            </div>
        </div>

        <div class="achievements mt-4">
            <div id="achievement-alert" class="alert alert-success d-none" role="alert">
                Achievement Unlocked! üéâ
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // --- GLOBAL VARIABLES & CONSTANTS ---

        // Game State Variables
        let score = 0;
        let multiplier = 1; // Pounds per click
        let multiplierCost = 10;
        let autoClickerCount = 0;
        let autoClickerCost = 50;
        let autoSpeedLevel = 1;
        let autoSpeedCost = 100;
        let lastSave = Date.now(); // For auto-save timing

        // Game Configuration Data
        const ranks = [
            { name: "Newbie Foodie", requirement: 0 },
            { name: "Snack Enthusiast", requirement: 50 },
            { name: "Food Explorer", requirement: 200 },
            { name: "Cuisine Master", requirement: 500 },
            { name: "Epic Gourmand", requirement: 1000 },
            { name: "Legendary Food King", requirement: 2500 },
            { name: "Minjigles God", requirement: 5000 }
        ];

        const achievements = [
            // Existing Corrected & Categorized
            { name: "First Bite", requirement: 1, unlocked: false, category: "milestone" },
            { name: "Hungry for More", requirement: 100, unlocked: false, category: "milestone" },
            { name: "Food Obeesed", requirement: 1000, unlocked: false, category: "milestone" }, // Score based
            { name: "mingled, and jingled ü¶ë", requirement: 1000, unlocked: false, category: "milestone" }, // Also score based, kept original req
            { name: "YOU BEAT MINGINGLES IN THE RANKING!!! üéâü™Ö", requirement: 2000000, unlocked: false, category: "milestone" },

            { name: "LAZY ü¶•, YOU ARE VERY USELESS AND LAZY!!!!!!", requirement: 1, unlocked: false, type: "autoClicker", category: "special" }, // Auto clicker related
            { name: "Automation Master", requirement: 5, unlocked: false, type: "autoClicker", category: "upgrade" },
            { name: "Speed Demon", requirement: 5, unlocked: false, type: "autoSpeed", category: "upgrade" },
            { name: "Speed v8", requirement: 8, unlocked: false, type: "autoSpeed", category: "upgrade" },
            { name: "speed v12", requirement: 12, unlocked: false, type: "autoSpeed", category: "upgrade" },
            { name: "speed v16", requirement: 16, unlocked: false, type: "autoSpeed", category: "upgrade" },

            // New Milestone Achievements (Score-based)
            { name: "Snack Packer", requirement: 5000, unlocked: false, category: "milestone" },
            { name: "Burger Flipper", requirement: 25000, unlocked: false, category: "milestone" },
            { name: "Feast Starter", requirement: 100000, unlocked: false, category: "milestone" },
            { name: "Millionaire Muncher", requirement: 1000000, unlocked: false, category: "milestone" },
            { name: "Burger Billionaire", requirement: 1000000000, unlocked: false, category: "milestone" },

            // New Upgrade Level Achievements
            // Click Power
            { name: "Heavy Hand", requirement: 25, unlocked: false, type: "clickPower", category: "upgrade" },
            { name: "Power Clicker", requirement: 50, unlocked: false, type: "clickPower", category: "upgrade" },
            { name: "Mighty Click", requirement: 100, unlocked: false, type: "clickPower", category: "upgrade" },
            // Auto Clicker Count
            { name: "Burger Brigade", requirement: 10, unlocked: false, type: "autoClicker", category: "upgrade" },
            { name: "Auto Army", requirement: 25, unlocked: false, type: "autoClicker", category: "upgrade" },
            { name: "Autonomous Collective", requirement: 50, unlocked: false, type: "autoClicker", category: "upgrade" },
            // Auto Speed Level
            { name: "Ludicrous Speed", requirement: 20, unlocked: false, type: "autoSpeed", category: "upgrade" },
            { name: "Warp Speed Engaged", requirement: 30, unlocked: false, type: "autoSpeed", category: "upgrade" },

            // New "Hidden" or Special Achievements (tracking logic to be added later)
            { name: "Just One More...", requirement: 666, unlocked: false, category: "special", type: "scorePrecision" },
            { name: "Click Frenzy", requirement: 10, unlocked: false, category: "special", type: "clicksInSec" },
            { name: "Early Bird", requirement: null, unlocked: false, category: "special", type: "timeOfDay" }
        ];

        // Three.js Variables
        let scene, camera, renderer, hamburgerModel, raycaster, mouse;
        const floatingBurgers3D = []; // Array to store active 3D floating burgers
        let isHovering = false; // For main hamburger hover state
        const originalScale = new THREE.Vector3(0.5, 0.5, 0.5); // Initial scale of main hamburger
        const hoverScale = new THREE.Vector3(0.55, 0.55, 0.55); // Scale on hover for main hamburger

        // Achievement Tracking Variables
        let clickTimestamps = []; // For "clicksInSec" achievement

        // --- UI ELEMENT REFERENCES ---
        const elements = {
            score: document.getElementById('score'),
            multiplier: document.getElementById('multiplier'),
            // foodBtn: document.getElementById('food-btn'), // 2D button, now unused
            foodContainer: document.getElementById('food-container'),
            multiplierUpgradeBtn: document.getElementById('multiplier-upgrade'),
            autoClickerBtn: document.getElementById('auto-clicker'),
            autoSpeedBtn: document.getElementById('auto-speed'),
            rankName: document.getElementById('rank-name'),
            achievementAlert: document.getElementById('achievement-alert'),
            mps: document.getElementById('mps'), // Pounds Per Second display
            rankProgress: document.getElementById('rank-progress'),
            clickPower: document.getElementById('click-power'), // Display for current click power
            autoCount: document.getElementById('auto-count'),   // Display for auto clicker count
            autoSpeedLevel: document.getElementById('auto-speed-level') // Display for auto speed level
        };

        // --- THREE.JS SETUP & ANIMATION ---

        /**
         * Initializes the Three.js scene, camera, renderer, lights, and initial objects.
         */
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha for transparent background if needed
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('threejs-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Fog for depth perception
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            // Create main interactive hamburger model
            hamburgerModel = createHamburgerModel();
            scene.add(hamburgerModel);

            // Create decorative background elements
            createBackgroundElements();

            // Position the main hamburger within the designated container area
            positionHamburger();

            camera.position.z = 5; // Camera distance from origin

            // Raycasting setup for mouse interactions
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event listeners for Three.js interactions
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('click', onThreeJSClick, false); // Renamed from onClick to avoid confusion
            window.addEventListener('resize', onWindowResize, false);
        }

        /**
         * Creates the main 3D hamburger model.
         * @returns {THREE.Group} The hamburger model.
         */
        function createHamburgerModel() {
            const group = new THREE.Group();
            const bunMaterial = new THREE.MeshStandardMaterial({ color: 0xDEA057, roughness: 0.6, metalness: 0.3 });
            const pattyMaterial = new THREE.MeshStandardMaterial({ color: 0x5C2E1A, roughness: 0.8, metalness: 0.2 });
            const lettuceMaterial = new THREE.MeshStandardMaterial({ color: 0x78A43D, roughness: 0.5, metalness: 0.1 });
            const tomatoMaterial = new THREE.MeshStandardMaterial({ color: 0xFF6347, roughness: 0.5, metalness: 0.1 });

            const topBun = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2), bunMaterial);
            topBun.position.y = 0.5;
            group.add(topBun);

            const bottomBun = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2), bunMaterial);
            bottomBun.position.y = -0.4;
            group.add(bottomBun);

            const patty = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.3, 32), pattyMaterial);
            patty.position.y = 0.1;
            group.add(patty);

            const lettuce = new THREE.Mesh(new THREE.CylinderGeometry(0.85, 0.85, 0.1, 32), lettuceMaterial);
            lettuce.position.y = 0.3;
            group.add(lettuce);

            const tomato = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 0.1, 32), tomatoMaterial);
            tomato.position.y = 0.4;
            group.add(tomato);

            group.scale.copy(originalScale);
            return group;
        }

        /**
         * Creates a smaller version of the hamburger model for floating animations.
         * @returns {THREE.Group | null} The mini hamburger model or null if main model doesn't exist.
         */
        function createMiniHamburgerModel() {
            if (!hamburgerModel) return null;

            const miniBurger = hamburgerModel.clone(true);
            miniBurger.scale.set(0.1, 0.1, 0.1);

            miniBurger.traverse(child => {
                if (child.isMesh) {
                    if (Array.isArray(child.material)) {
                        child.material = child.material.map(m => m.clone());
                    } else {
                        child.material = child.material.clone();
                    }
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(mat => {
                        mat.transparent = true;
                        mat.opacity = 1.0;
                    });
                }
            });
            return miniBurger;
        }

        /**
         * Positions the main hamburger model in the center of the 'food-container' div.
         */
        function positionHamburger() {
            if (!hamburgerModel || !camera) return;
            const foodContainer = document.getElementById('food-container');
            if (!foodContainer) return;

            const rect = foodContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const vec = new THREE.Vector3();
            const pos = new THREE.Vector3();
            vec.set( (centerX / window.innerWidth) * 2 - 1, -(centerY / window.innerHeight) * 2 + 1, 0.5 );
            vec.unproject(camera);
            vec.sub(camera.position).normalize();
            const distance = -camera.position.z / vec.z;
            pos.copy(camera.position).add(vec.multiplyScalar(distance));
            hamburgerModel.position.copy(pos);
            hamburgerModel.position.y -= 0.5; // Fine-tune vertical position
        }

        /**
         * Creates and distributes decorative 3D elements in the background.
         */
        function createBackgroundElements() {
            const geometries = [
                new THREE.SphereGeometry(1, 16, 16), new THREE.BoxGeometry(1, 1, 1),
                new THREE.ConeGeometry(1, 1.5, 16), new THREE.TorusKnotGeometry(1, 0.3, 100, 16)
            ];
            const materials = [
                new THREE.MeshStandardMaterial({ color: 0xff00ff, roughness: 0.5, metalness: 0.2 }), // Magenta
                new THREE.MeshStandardMaterial({ color: 0x00ffff, roughness: 0.5, metalness: 0.2 }), // Cyan
                new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.5, metalness: 0.2 }), // Yellow
                new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.5, metalness: 0.2 })  // Green
            ];

            for (let i = 0; i < 50; i++) {
                const geometry = geometries[Math.floor(Math.random() * geometries.length)];
                const material = materials[Math.floor(Math.random() * materials.length)].clone();
                material.transparent = true;
                material.opacity = 0.3 + Math.random() * 0.4;
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set( (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 50 - 20 );
                mesh.scale.setScalar(Math.random() * 2 + 0.5);
                mesh.rotation.set( Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2 );
                mesh.userData = {
                    isBackgroundElement: true,
                    rotationSpeed: { x: (Math.random() - 0.5) * 0.002, y: (Math.random() - 0.5) * 0.002 },
                    offset: Math.random() * Math.PI * 2
                };
                scene.add(mesh);
            }
        }

        /**
         * Handles window resize events to update camera and renderer.
         */
        function onWindowResize() {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            positionHamburger(); // Reposition hamburger on resize
        }

        /**
         * Handles mouse move events for raycasting and hover effects.
         * @param {MouseEvent} event The mouse event.
         */
        function onMouseMove(event) {
            if(!mouse) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        /**
         * Handles click events on the Three.js canvas, primarily for interacting with the main hamburger.
         * @param {MouseEvent} event The mouse event.
         */
        function onThreeJSClick(event) { // Renamed from onClick
            if (!hamburgerModel || !raycaster || !camera || !scene) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(hamburgerModel, true);

            if (intersects.length > 0) {
                addScore(multiplier); // addScore calls checkAchievements()

                // Track clicks for "clicksInSec" achievements
                const now = Date.now();
                clickTimestamps.push(now);
                clickTimestamps = clickTimestamps.filter(timestamp => now - timestamp < 1000);
                checkAchievements();

                // Create a floating 3D burger effect from the click position
                const foodContainerRect = elements.foodContainer.getBoundingClientRect();
                createFloatingBurger(
                    event.clientX, // Use direct mouse click coords for visual origin
                    event.clientY
                );

                // Click animation for the main hamburger
                const clickScaleDown = new THREE.Vector3(0.45, 0.45, 0.45);
                hamburgerModel.scale.copy(clickScaleDown);
                setTimeout(() => {
                    hamburgerModel.scale.copy(isHovering ? hoverScale : originalScale);
                }, 100);
            }
        }

        /**
         * The main animation loop for Three.js.
         */
        function animateThreeJS() {
            requestAnimationFrame(animateThreeJS);
            const delta = 0.016; // Approximate delta time (assuming ~60fps)

            // Main hamburger hover effect
            if (raycaster && hamburgerModel && scene && camera && renderer) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(hamburgerModel, true);
                if (intersects.length > 0) {
                    if (!isHovering) { isHovering = true; hamburgerModel.scale.copy(hoverScale); }
                } else {
                    if (isHovering) { isHovering = false; hamburgerModel.scale.copy(originalScale); }
                }
            }

            if (hamburgerModel) hamburgerModel.rotation.y += 0.005; // Gentle continuous rotation

            // Animate background elements
            scene.traverse(child => {
                if (child.userData.isBackgroundElement) {
                    child.rotation.x += child.userData.rotationSpeed.x;
                    child.rotation.y += child.userData.rotationSpeed.y;
                    child.position.y += Math.sin(Date.now() * 0.0005 + child.userData.offset) * 0.005;
                }
            });

            // Animate floating 3D burgers
            for (let i = floatingBurgers3D.length - 1; i >= 0; i--) {
                const burgerData = floatingBurgers3D[i];
                const burgerMesh = burgerData.mesh;
                burgerMesh.position.y += burgerData.velocityY * delta;
                burgerMesh.position.x += burgerData.velocityX * delta;
                burgerMesh.rotation.x += burgerData.rotationSpeed * delta * 5;
                burgerMesh.rotation.y += burgerData.rotationSpeed * delta * 5;
                burgerData.life -= delta;

                burgerMesh.traverse(subChild => { // Fade out
                    if (subChild.isMesh && subChild.material) {
                        if (!subChild.material.transparent) subChild.material.transparent = true;
                        subChild.material.opacity = Math.max(0, burgerData.life / burgerData.initialLife);
                    }
                });

                if (burgerData.life <= 0) { // Cleanup
                    scene.remove(burgerMesh);
                    burgerMesh.traverse(subChild => {
                        if (subChild.isMesh) {
                            if(subChild.geometry) subChild.geometry.dispose();
                            if(subChild.material) {
                                (Array.isArray(subChild.material) ? subChild.material : [subChild.material]).forEach(m => m.dispose());
                            }
                        }
                    });
                    floatingBurgers3D.splice(i, 1);
                }
            }
            if (scene && camera && renderer) renderer.render(scene, camera);
        }

        // --- CORE GAME LOGIC ---

        /**
         * Adds to the player's score and updates related UI elements.
         * @param {number} amount The amount to add to the score.
         */
        function addScore(amount) {
            score += amount;
            elements.score.textContent = formatNumber(score);
            checkRank();
            checkAchievements();
            updateRankProgress();
        }

        /**
         * Formats a number into a human-readable string (K for thousands, M for millions).
         * @param {number} num The number to format.
         * @returns {string} The formatted number string.
         */
        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        }

        /**
         * Creates a 3D floating burger animation starting from screen coordinates.
         * @param {number} screenX The X screen coordinate.
         * @param {number} screenY The Y screen coordinate.
         */
        function createFloatingBurger(screenX, screenY) {
            const miniBurgerMesh = createMiniHamburgerModel();
            if (!miniBurgerMesh || !scene || !camera || !hamburgerModel) return;

            const startPos = new THREE.Vector3();
            // Convert screen click to world coordinates near the main hamburger's surface
            const vec = new THREE.Vector3( (screenX / window.innerWidth) * 2 - 1, -(screenY / window.innerHeight) * 2 + 1, 0.5);
            vec.unproject(camera);
            // Place it slightly in front of the camera, then move towards the unprojected point at an estimated depth of the hamburger
            const dir = vec.sub(camera.position).normalize();
            const distance = hamburgerModel.position.distanceTo(camera.position) * 0.8; // Estimate distance to hamburger surface from camera
            startPos.copy(camera.position).add(dir.multiplyScalar(distance));

            miniBurgerMesh.position.copy(startPos);
            scene.add(miniBurgerMesh);

            const initialLifeTime = 1.0 + Math.random() * 0.5;
            floatingBurgers3D.push({
                mesh: miniBurgerMesh,
                velocityX: (Math.random() - 0.5) * 2.5,
                velocityY: 2.5 + Math.random() * 1.5,
                rotationSpeed: (Math.random() - 0.5) * 6,
                life: initialLifeTime,
                initialLife: initialLifeTime
            });
        }

        /**
         * Updates the player's rank based on their score.
         */
        function checkRank() {
            for (let i = ranks.length - 1; i >= 0; i--) {
                if (score >= ranks[i].requirement) {
                    if (elements.rankName.textContent !== ranks[i].name) {
                        elements.rankName.textContent = ranks[i].name;
                        elements.rankName.classList.add('level-up');
                        setTimeout(() => elements.rankName.classList.remove('level-up'), 1000);
                    }
                    break;
                }
            }
        }

        /**
         * Updates the visual progress bar for the current rank.
         */
        function updateRankProgress() {
            let currentRank = ranks[0];
            let nextRank = null;
            for (let i = 0; i < ranks.length; i++) {
                if (score >= ranks[i].requirement) {
                    currentRank = ranks[i];
                    if (i < ranks.length - 1) nextRank = ranks[i+1];
                } else {
                    if (!nextRank) nextRank = ranks[i]; // Handles case where player is below first rank with requirement > 0
                    break;
                }
            }

            if (nextRank && currentRank.name !== nextRank.name) { // Ensure not trying to divide by zero if current = next
                const progress = Math.min(100, ((score - currentRank.requirement) / (nextRank.requirement - currentRank.requirement)) * 100);
                elements.rankProgress.style.width = `${progress}%`;
                elements.rankProgress.setAttribute('aria-valuenow', progress);
            } else if (score >= currentRank.requirement && !nextRank) { // Max rank
                elements.rankProgress.style.width = '100%';
            } else { // Should not happen often, default to 0 or some initial state
                 elements.rankProgress.style.width = '0%';
            }
        }

        /**
         * Creates or removes visual elements representing auto-clickers. (Currently 2D)
         */
        function createAutoClickerVisual() { // This is still the 2D version
            const visual = document.createElement('img');
            visual.src = 'https://em-content.zobj.net/thumbs/120/apple/325/hamburger_1f354.png';
            visual.className = 'auto-clicker-visual';
            visual.style.transform = `rotate(${Math.random() * 360}deg)`;
            elements.foodContainer.appendChild(visual);
            setTimeout(() => visual.remove(), 3000);
        }
        function updateAutoClickerVisuals() { // This is still the 2D version
            const existingVisuals = document.querySelectorAll('.auto-clicker-visual');
            if (existingVisuals.length > autoClickerCount) {
                for (let i = autoClickerCount; i < existingVisuals.length; i++) existingVisuals[i].remove();
            } else {
                for (let i = existingVisuals.length; i < autoClickerCount; i++) createAutoClickerVisual();
            }
        }


        // --- ACHIEVEMENTS ---

        /**
         * Checks all defined achievements against current game state and unlocks them if criteria are met.
         */
        function checkAchievements() {
            achievements.forEach(achievement => {
                if (!achievement.unlocked) {
                    let unlockedThisCheck = false;
                    if (achievement.type === "autoClicker" && autoClickerCount >= achievement.requirement) unlockedThisCheck = true;
                    else if (achievement.type === "autoSpeed" && autoSpeedLevel >= achievement.requirement) unlockedThisCheck = true;
                    else if (achievement.type === "clickPower" && multiplier >= achievement.requirement) unlockedThisCheck = true;
                    else if (achievement.type === "scorePrecision" && score === achievement.requirement) unlockedThisCheck = true;
                    else if (achievement.type === "clicksInSec" && clickTimestamps.length >= achievement.requirement) unlockedThisCheck = true;
                    else if (achievement.type === "timeOfDay") {
                        const currentHour = new Date().getHours();
                        if (currentHour >= 5 && currentHour < 7) unlockedThisCheck = true;
                    } else if ((!achievement.type || achievement.category === "milestone") && score >= achievement.requirement && achievement.requirement !== null) {
                        unlockedThisCheck = true;
                    }

                    if (unlockedThisCheck) {
                        achievement.unlocked = true;
                        showAchievement(achievement.name);
                    }
                }
            });
        }

        /**
         * Displays an achievement notification.
         * @param {string} achievementName The name of the achievement to display.
         */
        function showAchievement(achievementName) {
            const alertEl = elements.achievementAlert;
            // The icon 'üèÜ' is added via CSS ::before pseudo-element.
            // This updates the text node part of the alert.
            alertEl.childNodes[alertEl.childNodes.length -1].nodeValue = ` Achievement Unlocked: ${achievementName} üéâ`;
            alertEl.classList.remove('d-none');

            // Force animation reset
            alertEl.style.animation = 'none';
            alertEl.offsetHeight; /* Trigger reflow */
            alertEl.style.animation = '';
            alertEl.style.animation = `slideInEnhanced 0.6s cubic-bezier(0.25, 0.8, 0.25, 1) forwards, pulseAchievement 1.8s infinite 0.7s`;

            setTimeout(() => {
                alertEl.classList.add('d-none');
                alertEl.style.animation = 'none'; // Stop animations when hidden
            }, 4000);
        }

        // --- LOCAL STORAGE (SAVE/LOAD) ---

        /**
         * Saves the current game state to local storage.
         */
        function saveGame() {
            const gameData = {
                score, multiplier, multiplierCost,
                autoClickerCount, autoClickerCost,
                autoSpeedLevel, autoSpeedCost,
                achievements // Save the whole achievements array (including unlocked status)
            };
            localStorage.setItem('minjiglesSimulator', JSON.stringify(gameData));
            lastSave = Date.now();
            // console.log("Game saved!"); // Optional: for debugging
        }

        /**
         * Loads game state from local storage.
         */
        function loadGame() {
            const savedData = localStorage.getItem('minjiglesSimulator');
            if (savedData) {
                const gameData = JSON.parse(savedData);
                score = gameData.score || 0;
                multiplier = gameData.multiplier || 1;
                multiplierCost = gameData.multiplierCost || 10;
                autoClickerCount = gameData.autoClickerCount || 0;
                autoClickerCost = gameData.autoClickerCost || 50;
                autoSpeedLevel = gameData.autoSpeedLevel || 1;
                autoSpeedCost = gameData.autoSpeedCost || 100;

                // Merge loaded achievements with current ones to preserve new definitions
                // while restoring unlocked status
                if (gameData.achievements) {
                    gameData.achievements.forEach(savedAch => {
                        const currentAch = achievements.find(a => a.name === savedAch.name);
                        if (currentAch) {
                            currentAch.unlocked = savedAch.unlocked;
                        }
                    });
                }

                // Update UI based on loaded data
                elements.score.textContent = formatNumber(score);
                elements.multiplier.textContent = multiplier;
                elements.clickPower.textContent = multiplier;
                elements.mps.textContent = formatNumber(autoClickerCount * autoSpeedLevel);
                elements.multiplierUpgradeBtn.textContent = `Upgrade Click Power (Cost: ${formatNumber(multiplierCost)})`;
                elements.autoClickerBtn.textContent = `Buy Auto Clicker (Cost: ${formatNumber(autoClickerCost)})`;
                elements.autoSpeedBtn.textContent = `Upgrade Speed (Cost: ${formatNumber(autoSpeedCost)})`;
                elements.autoCount.textContent = autoClickerCount;
                elements.autoSpeedLevel.textContent = autoSpeedLevel;

                checkRank();
                updateRankProgress();
                updateAutoClickerVisuals(); // For 2D auto clicker visuals
            }
        }

        // --- INITIALIZATION & EVENT LISTENERS ---

        // Parallax Hover Effect for Stats and Upgrades containers
        const parallaxContainers = document.querySelectorAll('.stats-container, .upgrades-container');
        parallaxContainers.forEach(container => {
            container.addEventListener('mousemove', (e) => {
                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                const {width, height} = rect;
                const rotateY = ((x - width / 2) / (width / 2)) * 7; // Max 7 deg
                const rotateX = -((y - height / 2) / (height / 2)) * 7; // Max 7 deg
                container.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            });
            container.addEventListener('mouseleave', () => {
                container.style.transform = 'perspective(1000px) rotateX(0) rotateY(0)';
            });
        });

        // Event listener for the multiplier upgrade button
        elements.multiplierUpgradeBtn.addEventListener('click', () => {
            if (score >= multiplierCost) {
                score -= multiplierCost;
                multiplier++;
                multiplierCost = Math.floor(multiplierCost * 1.5);
                elements.score.textContent = formatNumber(score);
                elements.multiplier.textContent = multiplier;
                elements.clickPower.textContent = multiplier;
                elements.multiplierUpgradeBtn.textContent = `Upgrade Click Power (Cost: ${formatNumber(multiplierCost)})`;
                elements.multiplier.classList.add('sparkle');
                setTimeout(() => elements.multiplier.classList.remove('sparkle'), 1000);
                checkAchievements();
            }
        });

        // Event listener for the auto-clicker purchase button
        elements.autoClickerBtn.addEventListener('click', () => {
            if (score >= autoClickerCost) {
                score -= autoClickerCost;
                autoClickerCount++;
                autoClickerCost = Math.floor(autoClickerCost * 1.8);
                elements.score.textContent = formatNumber(score);
                elements.autoClickerBtn.textContent = `Buy Auto Clicker (Cost: ${formatNumber(autoClickerCost)})`;
                elements.mps.textContent = formatNumber(autoClickerCount * autoSpeedLevel);
                elements.autoCount.textContent = autoClickerCount;
                updateAutoClickerVisuals(); // For 2D visuals
                checkAchievements();
            }
        });

        // Event listener for the auto-clicker speed upgrade button
        elements.autoSpeedBtn.addEventListener('click', () => {
            if (score >= autoSpeedCost) {
                score -= autoSpeedCost;
                autoSpeedLevel++;
                autoSpeedCost = Math.floor(autoSpeedCost * 2);
                elements.score.textContent = formatNumber(score);
                elements.autoSpeedBtn.textContent = `Upgrade Speed (Cost: ${formatNumber(autoSpeedCost)})`;
                elements.mps.textContent = formatNumber(autoClickerCount * autoSpeedLevel);
                elements.autoSpeedLevel.textContent = autoSpeedLevel;
                checkAchievements();
            }
        });

        // Auto-save interval (every 30 seconds)
        setInterval(saveGame, 30000);
        // Save game when the window is about to be unloaded
        window.onbeforeunload = saveGame;

        // Auto-clicker interval (adds score every second based on auto-clickers owned and their speed)
        setInterval(() => {
            if (autoClickerCount > 0 && hamburgerModel && camera && scene) {
                addScore(autoClickerCount * autoSpeedLevel); // addScore calls checkAchievements

                // Create a floating 3D burger originating from the main hamburger for auto-clicks
                const screenPosVec = new THREE.Vector3();
                hamburgerModel.getWorldPosition(screenPosVec);
                screenPosVec.project(camera);
                const screenX = (screenPosVec.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-screenPosVec.y * 0.5 + 0.5) * window.innerHeight;
                const randomOffsetX = (Math.random() - 0.5) * (hamburgerModel.scale.x * 100);
                const randomOffsetY = (Math.random() - 0.5) * (hamburgerModel.scale.y * 100);
                createFloatingBurger(screenX + randomOffsetX, screenY + randomOffsetY);
            }
        }, 1000);

        // Initialize the game
        loadGame();    // Load saved state first
        initThreeJS(); // Then initialize Three.js
        animateThreeJS(); // Start the animation loop
        updateRankProgress(); // Initial rank progress update
        checkAchievements(); // Check for any initially met time-based achievements etc.

    </script>
</body>
</html>
